// (c) Electronic Arts. All Rights Reserved.

#include <unit/unit.h>

#include <EABase/eabase.h>
#include <eaphysics/base.h>

#include <rw/collision/libcore.h>

#include <eacollision/features/maximumfeature.h>

#include "benchmarkenvironment/timer.h"
#include "stdio.h"     // for sprintf()
#include "random.hpp"
#include "testsuitebase.h" // For TestSuiteBase

using namespace rwpmath;
using namespace rw::collision;

#if defined EA_DEBUG
#define NUM_TEST 10        // debug mode, fewer tests
#else
#define NUM_TEST 1000
#endif


class TestContacts: public tests::TestSuiteBase
{
public:
    virtual void Initialize()
    {
        SuiteName("TestContacts");

        EATEST_REGISTER("TestFatBox", "Contacts generated by fat boxes", TestContacts, TestFatBox);
        EATEST_REGISTER("TestSphereCapsule", "Test Sphere/Capsule separating distance is reasonable", TestContacts, TestSphereCapsule);
        EATEST_REGISTER("TestTriangleSphereCapsule", "Test Triangle vs Tri/Sphere/Capsule separating distance is reasonable", TestContacts, TestTriangleSphereCapsule);
        EATEST_REGISTER("TestBoxSphereCapsule", "Test Box vs Box/Sphere/Capsule separating distance is reasonable", TestContacts, TestBoxSphereCapsule);
        EATEST_REGISTER("TestBoxTriangle", "Test Box vs Triangle separating distance is reasonable", TestContacts, TestBoxTriangle);
        EATEST_REGISTER("TestCylinder", "Test Cylinder vs other primitive separating distance is reasonable", TestContacts, TestCylinder);
        EATEST_REGISTER("BenchmarkComputeContacts", "Benchmark all combinations of ComputeContactPoints", TestContacts, BenchmarkComputeContacts);
    }

    void SetupSuite()
    {
        tests::TestSuiteBase::SetupSuite();

        // Initialise the collision system
        Volume::InitializeVTable();
    }

    void TeardownSuite()
    {
        tests::TestSuiteBase::TeardownSuite();
    }

    static const uint32_t numTest = NUM_TEST;

private:

    void TestFatBox();

    void TestComputeContactPoints(uint32_t type1, uint32_t type2, uint32_t numTest, float distanceFromOrigin = 1000.f);
    void BenchmarkComputeContactPoints(uint32_t type1, uint32_t type2, uint32_t numTest);

    void BenchmarkComputeContacts();
    void TestSphereCapsule();
    void TestTriangleSphereCapsule();
    void TestBoxSphereCapsule();
    void TestBoxTriangle();
    void TestCylinder();

} TestContactsSingleton;

#undef NUM_TEST

//*************************************************************************************************

static bool IsCollinear(GPInstance::ContactPoints::PointPair& pair, Vector3::InParam normal)
{
    Vector3 sepdir = pair.p1 - pair.p2;
    VecFloat sep = Magnitude(sepdir);

    return Abs(Dot(sepdir, normal)) > 0.999f * sep;
}


//*************************************************************************************************

void TestContacts::TestFatBox()
{
    Matrix44Affine tm1 = Matrix44AffineFromAxisRotationAngle(GetVector3_YAxis(), 0.01f);
    Matrix44Affine tm2 = Matrix44AffineFromAxisRotationAngle(GetVector3_YAxis(), -0.02f);

    tm1.SetW(Vector3(14.f, 5.f, 26.f));
    tm2.SetW(Vector3(16.4f, 5.1f, 25.f));

    GPBox gp1;
    gp1.Initialize(tm1.GetW(), tm1.GetX(), tm1.GetY(), tm1.GetZ(),
        Vector3(1.f,2.f,3.f), .2f, 0, 101, 999);

    GPBox gp2;
    gp2.Initialize(tm2.GetW(), tm2.GetX(), tm2.GetY(), tm2.GetZ(),
        Vector3(1.f,2.f,3.f), .2f, 0, 102, 999);

    GPInstance::ContactPoints result;

    uint32_t numpoints = rw::collision::detail::ComputeContactPoints(gp1, gp2, 4.f, result);

    EATESTAssert(numpoints == 4, "Insufficient points returned.");
    EATESTAssert(numpoints == result.numPoints, "Wrong return value.");
    EATESTAssert(IsSimilar(Magnitude(result.normal), GetVecFloat_One(), VecFloat(1e-5f)) , "normal isn't unit.");

    for (uint32_t i = 0; i < numpoints; ++i)
    {
        EATESTAssert(IsCollinear(result.pointPairs[i], result.normal), "result pair is not collinear");
    }
}

//*************************************************************************************************

/*
Not truly random, because m[2][0] is always zero.
*/
inline
Matrix33 RandomRotationMatrix()
{
    Matrix33 m;
    m.SetY(RandomUnitVector3());
    m.SetX(Abs(m.GetY().X()) < 0.5f ? GetVector3_XAxis() : GetVector3_YAxis());
    m.SetZ(Normalize(Cross(m.GetX(), m.GetY())));
    m.SetX(Cross(m.GetY(), m.GetZ()));
    return m;
}


/*
Find the max feature on the gpInstance in specified direction.  A feature is a convex set of points, which represents
a vertex (1) edge (2) or face (3 or more points).   This calls the GetmaxFeature from the primitive package.
*/
static
uint32_t GetMaximumFeature(Vector3* result,
                        Vector3::InParam dir,
                        GPInstance& gp,
                        VecFloatInParam cos2max)
{
    Vector3 dim;
    switch (gp.Type())
    {
    default: return 0;
    case GPInstance::SPHERE :
        return EA::Collision::GetMaximumFeatureSphere(result, dir, gp.Pos(), cos2max);
    case GPInstance::CAPSULE :
        return EA::Collision::GetMaximumFeatureCapsule(result, dir, gp.Pos(),
                        static_cast<const GPCapsule&>(gp).Axis(),
                        static_cast<const GPCapsule&>(gp).HalfHeight(),cos2max);
    case GPInstance::TRIANGLE :
        return EA::Collision::GetMaximumFeatureTriangle(result, dir,
                        static_cast<const GPTriangle&>(gp).Vertex0(),
                        static_cast<const GPTriangle&>(gp).Vertex1(),
                        static_cast<const GPTriangle&>(gp).Vertex2(),cos2max);
    case GPInstance::BOX :
        dim = static_cast<const GPBox&>(gp).HalfSizeDimensionsVec();
        return EA::Collision::GetMaximumFeatureBox(result, dir, gp.Pos(),
                        gp.FaceNormal(0), gp.FaceNormal(1), gp.FaceNormal(2),
                        dim.X(), dim.Y(), dim.Z(),cos2max);
    case GPInstance::CYLINDER :
        return EA::Collision::GetMaximumFeatureCylinder(result, dir, gp.Pos(),
                        static_cast<const GPCylinder&>(gp).Axis(),
                        static_cast<const GPCylinder&>(gp).HalfHeight(),
                        static_cast<const GPCylinder&>(gp).Radius(),cos2max);
    }
}


/*
Return the point on the surface of the GPinstance farthest away in the specified direction.
The FATNESS is NOT added to the result.
*/
static
Vector3 GetMaximumPoint(Vector3::InParam dir, GPInstance& gp)
{
    Vector3 result[4];
    result[0] = gp.Pos();
    uint32_t n = GetMaximumFeature(result, dir, gp, 0.9999f);
    uint32_t j = 0;
    for (uint32_t i = 1; i < n; ++i)
    {
        if (Dot(result[j] - result[i], dir) < 0.f)
        {
            j = i;
        }
    }
    return result[j];
}

/*
Given two gpinstance, and direction axis, return the separation along the axis, or negative if they overlap.
*/
static
float GetAxisSeparation(Vector3::InParam axis, GPInstance& gp1, GPInstance& gp2)
{
    Vector3 p1 = GetMaximumPoint(-axis, gp1);
    Vector3 p2 = GetMaximumPoint( axis, gp2);
    return Dot(axis, p1 - p2) - (gp1.Fatness() + gp2.Fatness());
}



/**
This generates a gpinstance
*/
inline
void InitGP(GPInstance& gp, Vector3::InParam origin, Matrix33::InParam m, float offset, uint32_t gptype)
{
    Vector3 p = origin + m.GetX() * offset + m.GetZ() * offset;
    switch (gptype % 5)
    {
    case 0:
        ((GPSphere&)gp).Initialize(p, .1f, 0, 0, 0);
        break;
    case 1:
        ((GPCapsule&)gp).Initialize(p, .1f, m.GetY(), 1.f, 0, 0, 0);
        break;
    case 2:
        ((GPTriangle&)gp).Initialize(p + m.GetY(), p - m.GetY(), p + m.GetX() + m.GetZ(), .1f, GPInstance::FLAG_TRIANGLEDEFAULT, Vector3(-1.0f,-1.0f,-1.0f), 0, 0);
        break;
    case 3:
        ((GPCylinder&)gp).Initialize(p, .1f, m.GetY(), 1.f, .1f, 0, 0, 0, m.GetZ(), m.GetX());
        break;
    case 4:
        ((GPBox&)gp).Initialize(p, m.GetY(), m.GetZ(), m.GetX(), Vector3(1.f, 1.f, .1f), .1f, 0, 0, 0);
        break;
    }
}

/**
This test create two volumes, one at the origin, and one at 4*local_X_axis
The second is rotated slightly around the local X and Z axes.
This tests the notorious "blackbug" 16287.
The separation returned from CCP is compared to the axis between the centers.
*/

void TestContacts::TestComputeContactPoints(uint32_t type1, uint32_t type2, uint32_t numTest, float distanceFromOrigin)
{
    GPInstance gp1, gp2;
    uint32_t i, errCount=0;

    const float error_tolerance = 1e-6f * distanceFromOrigin;
    rw::math::SeedRandom(9u);                             // SEED RANDOM NUMBER GENERATOR

    for (i = 0; i < numTest; ++i)
    {
        Matrix33 m1 = RandomRotationMatrix();

        float dx = Random01() * 0.001f;
        float dz = Random01() * 0.001f;

        uint32_t jj = Random((uint32_t)0, (uint32_t)7);
        while (jj-->0)  dx*=.1f;
        jj = Random((uint32_t)0, (uint32_t)7);
        while (jj-->0)  dz*=.1f;

        // NOTE this "rotation" only works when dx,dz is very small (less than 0.001)
        Matrix33 m2 = m1 * (1.f - (dx*dx + dz*dz)) +
            Matrix33(m1.GetY()*-dx,  m1.GetX()*dx + m1.GetZ()*dz,   m1.GetY()*-dz);

        Vector3 origin = RandomVector3(distanceFromOrigin);

        InitGP(gp1, origin, m1, 0.0f, type1);
        InitGP(gp2, origin, m2, 4.0f, type2);

        GPInstance::ContactPoints result;

        uint32_t numpoints = 0;

        //------------------------------------------
        numpoints = rw::collision::detail::ComputeContactPoints(gp1, gp2, 8.f, result);
        //------------------------------------------

        EATESTAssert(numpoints > 0, "wrong numpoints.");
        EATESTAssert(Dot(result.normal, m1.GetX()) < 0.f, "wrong normal.");

        float interval_dist = GetAxisSeparation(result.normal, gp1, gp2);
        Vector3 axis = Normalize(gp1.mPos - gp2.mPos);
        float axis_dist = GetAxisSeparation(axis, gp1, gp2);

        float contact_dist = 999;
        for (uint32_t k=0; k<result.numPoints; ++k)
        {
            contact_dist = Min(contact_dist, (float) Dot(result.normal, result.pointPairs[k].p1 - result.pointPairs[k].p2));
        }

        if (interval_dist - contact_dist > error_tolerance || axis_dist - contact_dist > error_tolerance)
        {
            ++errCount;     // for debugging, set breakpoint here
        }

        EATESTAssert(interval_dist - contact_dist < error_tolerance, "wrong separation distance.");
        EATESTAssert(axis_dist - contact_dist < error_tolerance, "the contact normal is not the best separating axis.");
    }
    EATESTAssert(errCount == 0, "errors found.");
}

/**
This benchmark creates two volumes, one at the origin, and one at 4*local_X_axis
*/

void TestContacts::BenchmarkComputeContactPoints(uint32_t type1, uint32_t type2, uint32_t numTest)
{
    GPInstance gp1, gp2;
    uint32_t i;

    float minTime = MAX_FLOAT;
    float maxTime = 0;
    float totalTime = 0;

    rw::math::SeedRandom(9u);                             // SEED RANDOM NUMBER GENERATOR

    for (i = 0; i < numTest; ++i)
    {
        Matrix33 m1 = RandomRotationMatrix();
        Matrix33 m2 = RandomRotationMatrix();

        VecFloat distanceFromOrigin = 10.f;

        Vector3 origin = RandomVector3(distanceFromOrigin);

        InitGP(gp1, origin, m1, 0.0f, type1);
        InitGP(gp2, origin, m2, 4.0f, type2);

        GPInstance::ContactPoints result;

        //------------------------------------------
        benchmarkenvironment::Timer timer;
        timer.Start();
        rw::collision::detail::ComputeContactPoints(gp1, gp2, 8.f, result);
        timer.Stop();

        float t = timer.AsSeconds() * 1e6f;       // unit = microseconds
        totalTime += t;
        minTime = Min(minTime, t);
        maxTime = Max(maxTime, t);
    }

    //------------- benchmark result -----------------------------
    const char* typenames[] = {"Sphere","Capsule","Triangle","Cylinder","Box"};      // base on InitGP
    char name[256];
    sprintf(name, "TestContacts - ComputeContactPoints - %s vs %s", typenames[type1], typenames[type2]);
    EATESTSendBenchmark(name, (double) totalTime / numTest, (double) minTime, (double) maxTime);
}

/*
This runs ComputeContactPoints a lot of times for every possible combination of types.
*/
void TestContacts::BenchmarkComputeContacts()
{
    const uint32_t numtype = 5;

    for (uint32_t i = 0; i < numtype; ++i)
    {
        for (uint32_t j = 0; j < numtype; ++j)
        {
            BenchmarkComputeContactPoints(i, j, numTest);
        }
    }
}


/*
Test Sphere/Capsule separating distance is reasonable
*/
void TestContacts::TestSphereCapsule()
{
    TestComputeContactPoints(0, 0, numTest);
    TestComputeContactPoints(0, 1, numTest);
    TestComputeContactPoints(1, 0, numTest);
}

/*
Test Triangle vs Tri/Sphere/Capsule separating distance is reasonable
*/
void TestContacts::TestTriangleSphereCapsule()
{
    TestComputeContactPoints(2, 0, numTest);
    TestComputeContactPoints(0, 2, numTest);
    TestComputeContactPoints(1, 2, numTest);
    TestComputeContactPoints(2, 1, numTest);
    TestComputeContactPoints(2, 2, numTest);
}

/*
Test Box vs Box/Sphere/Capsule separating distance is reasonable
*/
void TestContacts::TestBoxSphereCapsule()
{
    TestComputeContactPoints(4, 0, numTest);
    TestComputeContactPoints(0, 4, numTest);
    TestComputeContactPoints(1, 4, numTest);
    TestComputeContactPoints(4, 1, numTest);
    TestComputeContactPoints(4, 4, numTest);
}

/*
Test Box vs Triangle separating distance is reasonable
*/
void TestContacts::TestBoxTriangle()
{
    TestComputeContactPoints(2, 4, numTest);
    TestComputeContactPoints(4, 2, numTest);
}

/*
Test Cylinder vs other primitive separating distance is reasonable
*/
void TestContacts::TestCylinder()
{
    TestComputeContactPoints(3, 0, numTest);
    TestComputeContactPoints(0, 3, numTest);
    TestComputeContactPoints(1, 3, numTest);
    TestComputeContactPoints(3, 1, numTest);
    TestComputeContactPoints(2, 3, numTest);    // tri vs cyl
    TestComputeContactPoints(3, 2, numTest);
    TestComputeContactPoints(3, 3, numTest);
    TestComputeContactPoints(3, 4, numTest);    // box vs cyl
    TestComputeContactPoints(4, 3, numTest);
}


